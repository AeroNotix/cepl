;; Raymarcher! -currently broken-

(defparameter *gpu-array* nil)
(defparameter *vertex-stream* nil)
(defparameter *loop* 0.0)

(defsmacro density-normal (object-call position-arg-num)
  (when (not (listp object-call)) (error "object-call form must a list"))
  (let ((p (1+ position-arg-num))
        (oc object-call))
    `(normalize 
      (v! (- ,(utils:replace-nth oc p `(+ ,(nth p oc) (v! 0.01  0.0  0.0)))
             ,(utils:replace-nth oc p `(- ,(nth p oc) (v! 0.01  0.0  0.0))))
          (- ,(utils:replace-nth oc p `(+ ,(nth p oc) (v!  0.0 0.01  0.0)))
             ,(utils:replace-nth oc p `(- ,(nth p oc) (v!  0.0 0.01  0.0))))
          (- ,(utils:replace-nth oc p `(+ ,(nth p oc) (v!  0.0  0.0 0.01)))
             ,(utils:replace-nth oc p `(- ,(nth p oc) (v!  0.0  0.0 0.01))))))))

(defsfun sphere ((p :vec3) (r :float)) 
  (return (- (length p) r)))

(defsfun box ((p :vec3) (b :vec3)) 
  (let ((d (- (abs p) b)))
    (return (+ (min (max (x d) (max (y d) (z d))) 0.0)
               (length (max d 0.0))))))

(deffshader frag ((posxy :vec2) &uniform (loop :float) (eye-pos :vec3))
  (let* ((eye-dir (normalize (v! (x posxy) (y posxy) 1.0)))
         (e eye-pos)
         (output (v! 0.0 0.0 0.0))
         (box-dim (v! 1.0 2.0 1.0)))
    (for (i 0) (< i 20) (++ i)
         (let ((d (sphere e 1.4)))
           (if (<= d 0.0)
               (let ((norm (density-normal (sphere e 1.4) 0)))
                 (setf output (v! (+ 0.3 (y norm)) 
                                  0.0
                                  (+ 0.5 (mix (y norm) (x norm) 1.0))))
                 (break)))
           (setf d (max d 0.01))
           (setf e (+ e (* eye-dir d)))))
    (out output-color (v! output 1.0))))

(deffshader old-frag ((posxy :vec2) &uniform (loop :float) (eye-pos :vec3))
   (labels ((object ((p :vec3) (r :float) (l :float))
              (return (+ (* 0.2 (+ (y p)
                                   (sin (+ (* (+ (cos l) 8.0) (x p)) l))))
                         (- (length p) r)))))
     (let* ((eye-pos (v! 0.0 0.0 -5.0))
            (eye-dir (normalize (v! (x posxy) (y posxy) 1.0)))
            (e eye-pos)
            (output (v! 0.0 0.0 0.0)))
       (for (i 0) (< i 20) (++ i)
            (let ((d (object e 1.4 loop)))
              (if (<= d 0.0)
                  (let ((norm (normalize (v! (- (object (+ e (v! 0.01 0.0 0.0)) 1.4 loop)
                                                (object (- e (v! 0.01 0.0 0.0)) 1.4 loop))
                                             (- (object (+ e (v! 0.0 0.01 0.0)) 1.4 loop)
                                                (object (- e (v! 0.0 0.01 0.0)) 1.4 loop))
                                             (- (object (+ e (v! 0.0 0.0 0.01)) 1.4 loop)
                                                (object (- e (v! 0.0 0.0 0.01)) 1.4 loop))))))
                    (setf output (v! (+ 0.3 (* 0.5 (y norm)))
                                     0.0
                                     (+ 0.5 (* 0.2 (mix (y norm) (x norm)
                                                        (sin (* 1.0 loop))))) ))
                    (break)))
              (setf d (max d 0.01))
              (setf e (+ e (* eye-dir d)))))
       (out output-color (v! output 1.0)))))

(defpipeline prog-1 ((position :vec4) &uniform (loop :float) (eye-pos :vec3))
  (:vertex (setf gl-position position) (out posxy (swizzle position :xy)))
  frag)

(let ((running nil))
  (defun run-demo ()
    (cgl:clear-color 0.0 0.0 0.0 0.0)
    (setf *gpu-array* (make-gpu-array (list (v! -1.0  -1.0  0.0  1.0)
                                            (v!  1.0  -1.0  0.0  1.0)
                                            (v!  1.0   1.0  0.0  1.0)
                                            (v!  1.0   1.0  0.0  1.0)
                                            (v! -1.0   1.0  0.0  1.0)
                                            (v! -1.0  -1.0  0.0  1.0))
                                      :element-type :vec4
                                      :dimensions 6))
    (setf *vertex-stream* (make-vertex-stream *gpu-array*))
    (setf running t)
    (loop :while running :do
       (case-events (event) (:quit () (setf running nil)))
       (cepl-utils:update-swank)
       (continuable (draw *vertex-stream*))))
  (defun stop-demo () (setf running nil)))

(defun draw (gstream)
  (setf *loop* (+ 0.01 *loop*))
  (gl:clear :color-buffer-bit)
  (prog-1 gstream :loop *loop* :eye-pos (v! 0 0 -5))
  (gl:flush)
  (cgl:update-display))

