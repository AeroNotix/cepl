image => t-array

(make-t-array (64 64 64)) ;;3d t-array
(make-t-array (64 64 64) :mipmap t) ;;3d t-array with mipmaps
(make-t-array (16 16) :backed-by b-array) ;;2d t-array with buffer storage

(make-layered-t-array (64 64) 3 :mipmap t) ;; 2d t-array with mipmaps and
                                           ;; 3 layers
;;meh

(make-t-array (64 64) :mipmap t :layers 3) ;; 2d t-array with mipmaps and
                                           ;; 3 layers
;;better
;; bnut no we are mixing structure again

;; (cube-face (layer-ref (mip-ref texture 0) 0) 0)
;; CL-USER> <t-array #323523>
;; --- or maybe ---
;; CL-USER> <gpu-array #323523>

;; Maybe gpu-arrays are backed by whatever and their backing dictates
;; behaviour

;; Textures are complex custom structures which can have:
;; mipmaps, layers(arrays), and cubes 
;; The leaves of these structures are (texture backed)gpu-arrays
;; of up to three dimensions.

(defun valid-texture-feature-combination (dimensions mipmap layer-count cubes 
                                          pot)
  )

(defun make-texture (dimensions &key (mipmap nil) (layer-count 0) (cubes nil)
                                  (rectangle nil) (immutable t))
  (if immutable
      ;; check for power of two - handle or warn
      (let ((array-type))
        )
      (error "Textures with mutable storage are not yet implemented")))

(defclass texture-backed-gpu-array ()
  ((texture-id :initform (gen-texture) :accessor texture-id)
   (array-type :initarg array-type)
   (mipmap :initarg mipmap)
   (layer-count :initarg layer-count)
   (cubes :initarg cubes)))

(defclass texture-mipmap-level ()
  ())

(defclass texture-array-layer ()
  ())

(defclass texture-cube ()
  ())
